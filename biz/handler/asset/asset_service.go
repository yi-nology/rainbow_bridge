// Code generated by hertz generator.

package asset

import (
	"context"
	"errors"
	"fmt"
	"io"
	"strings"

	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/protocol/consts"
	"github.com/yi-nology/rainbow_bridge/biz/handler"
	asset "github.com/yi-nology/rainbow_bridge/biz/model/asset"
	"github.com/yi-nology/rainbow_bridge/biz/service"
)

var svc *service.Service

func SetService(s *service.Service) {
	svc = s
}

// List .
// @router /api/v1/asset/list [GET]
func List(ctx context.Context, c *app.RequestContext) {
	environmentKey := strings.TrimSpace(c.Query("environment_key"))
	pipelineKey := strings.TrimSpace(c.Query("pipeline_key"))
	if environmentKey == "" || pipelineKey == "" {
		c.JSON(consts.StatusOK, &asset.AssetListResponse{
			Code:  consts.StatusBadRequest,
			Msg:   "error",
			Error: "environment_key and pipeline_key are required",
		})
		return
	}
	assets, err := svc.ListAssets(handler.EnrichContext(ctx, c), environmentKey, pipelineKey)
	if err != nil {
		c.JSON(consts.StatusOK, &asset.AssetListResponse{
			Code:  consts.StatusInternalServerError,
			Msg:   "error",
			Error: err.Error(),
		})
		return
	}
	c.JSON(consts.StatusOK, &asset.AssetListResponse{
		Code: consts.StatusOK,
		Msg:  "OK",
		Data: &asset.AssetListData{
			Total: int32(len(assets)),
			List:  assets,
		},
	})
}

// Upload .
// @router /api/v1/asset/upload [POST]
func Upload(ctx context.Context, c *app.RequestContext) {
	// Check Content-Length header first
	contentLength := c.Request.Header.ContentLength()
	if contentLength > handler.MaxUploadSize {
		c.JSON(consts.StatusOK, &asset.UploadAssetResponse{
			Code:  consts.StatusBadRequest,
			Msg:   "error",
			Error: "file too large",
		})
		return
	}

	fileHeader, err := c.FormFile("file")
	if err != nil {
		c.JSON(consts.StatusOK, &asset.UploadAssetResponse{
			Code:  consts.StatusBadRequest,
			Msg:   "error",
			Error: err.Error(),
		})
		return
	}

	// Validate file size
	if fileHeader.Size > handler.MaxUploadSize {
		c.JSON(consts.StatusOK, &asset.UploadAssetResponse{
			Code:  consts.StatusBadRequest,
			Msg:   "error",
			Error: "file too large",
		})
		return
	}

	if fileHeader.Size == 0 {
		c.JSON(consts.StatusOK, &asset.UploadAssetResponse{
			Code:  consts.StatusBadRequest,
			Msg:   "error",
			Error: "file is empty",
		})
		return
	}

	// Validate MIME type from header
	declaredType := fileHeader.Header.Get("Content-Type")
	normalizedType := strings.ToLower(strings.TrimSpace(declaredType))
	if idx := strings.Index(normalizedType, ";"); idx > 0 {
		normalizedType = strings.TrimSpace(normalizedType[:idx])
	}
	if !handler.AllowedMimeTypes[normalizedType] {
		c.JSON(consts.StatusOK, &asset.UploadAssetResponse{
			Code:  consts.StatusBadRequest,
			Msg:   "error",
			Error: "unsupported file type",
		})
		return
	}

	// Validate environment and pipeline keys
	environmentKey := string(c.FormValue("environment_key"))
	pipelineKey := string(c.FormValue("pipeline_key"))
	if environmentKey == "" || pipelineKey == "" {
		c.JSON(consts.StatusOK, &asset.UploadAssetResponse{
			Code:  consts.StatusBadRequest,
			Msg:   "error",
			Error: "environment_key and pipeline_key are required",
		})
		return
	}

	file, err := fileHeader.Open()
	if err != nil {
		c.JSON(consts.StatusOK, &asset.UploadAssetResponse{
			Code:  consts.StatusBadRequest,
			Msg:   "error",
			Error: err.Error(),
		})
		return
	}
	defer file.Close()

	// Use LimitReader to prevent reading more than allowed
	data, err := io.ReadAll(io.LimitReader(file, handler.MaxUploadSize+1))
	if err != nil {
		c.JSON(consts.StatusOK, &asset.UploadAssetResponse{
			Code:  consts.StatusInternalServerError,
			Msg:   "error",
			Error: err.Error(),
		})
		return
	}

	// Double-check size after reading
	if int64(len(data)) > handler.MaxUploadSize {
		c.JSON(consts.StatusOK, &asset.UploadAssetResponse{
			Code:  consts.StatusBadRequest,
			Msg:   "error",
			Error: "file too large",
		})
		return
	}

	input := &service.FileUploadInput{
		EnvironmentKey: environmentKey,
		PipelineKey:    pipelineKey,
		Remark:         string(c.FormValue("remark")),
		FileName:       fileHeader.Filename,
		ContentType:    fileHeader.Header.Get("Content-Type"),
		Data:           data,
	}

	assetItem, reference, err := svc.UploadAsset(handler.EnrichContext(ctx, c), input)
	if err != nil {
		c.JSON(consts.StatusOK, &asset.UploadAssetResponse{
			Code:  consts.StatusInternalServerError,
			Msg:   "error",
			Error: err.Error(),
		})
		return
	}

	c.JSON(consts.StatusOK, &asset.UploadAssetResponse{
		Code: consts.StatusOK,
		Msg:  "OK",
		Data: &asset.AssetData{
			Asset:     assetItem,
			Reference: reference,
		},
	})
}

// GetFile .
// @router /api/v1/asset/file/{file_id} [GET]
func GetFile(ctx context.Context, c *app.RequestContext) {
	fileID := c.Param("file_id")
	if fileID == "" {
		fileID = c.Param("fileID")
	}

	assetItem, reader, err := svc.GetAssetFile(handler.EnrichContext(ctx, c), fileID)
	if err != nil {
		if errors.Is(err, service.ErrAssetNotFound) || strings.Contains(err.Error(), "not found") {
			handler.WriteNotFound(c, err)
			return
		}
		handler.WriteInternalError(c, err)
		return
	}
	defer reader.Close()

	// Read content
	content, err := io.ReadAll(reader)
	if err != nil {
		handler.WriteInternalError(c, err)
		return
	}

	contentType := assetItem.ContentType
	if contentType == "" {
		contentType = consts.MIMEApplicationOctetStream
	}
	c.Response.Header.Set("Content-Type", contentType)
	if assetItem.FileName != "" {
		c.Response.Header.Set("Content-Disposition", fmt.Sprintf("inline; filename=\"%s\"", assetItem.FileName))
	}
	c.Data(consts.StatusOK, contentType, content)
}
