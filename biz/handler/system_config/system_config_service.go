// Code generated by hertz generator.

package system_config

import (
	"context"
	"errors"

	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/protocol/consts"
	"github.com/yi-nology/rainbow_bridge/biz/handler"
	"github.com/yi-nology/rainbow_bridge/biz/model/common"
	systemConfig "github.com/yi-nology/rainbow_bridge/biz/model/system_config"
	"github.com/yi-nology/rainbow_bridge/biz/service"
)

var svc *service.Service

func SetService(s *service.Service) {
	svc = s
}

// Get .
// @router /api/v1/system-config/get [GET]
// SystemConfig is environment-scoped only (no pipeline_key dependency).
func Get(ctx context.Context, c *app.RequestContext) {
	var req systemConfig.GetSystemConfigRequest
	if err := c.BindAndValidate(&req); err != nil {
		handler.RespondError(c, consts.StatusBadRequest, err)
		return
	}

	if req.EnvironmentKey == "" {
		handler.RespondError(c, consts.StatusBadRequest, errors.New("environment_key is required"))
		return
	}
	if req.ConfigKey == "" {
		handler.RespondError(c, consts.StatusBadRequest, errors.New("config_key is required"))
		return
	}

	cfg, err := svc.GetSystemConfig(handler.EnrichContext(ctx, c), req.EnvironmentKey, req.ConfigKey)
	if err != nil {
		status := consts.StatusInternalServerError
		if errors.Is(err, service.ErrSystemConfigNotFound) {
			status = consts.StatusNotFound
		}
		handler.RespondError(c, status, err)
		return
	}

	resp := &systemConfig.SystemConfigResponse{
		OperateResponse: &common.OperateResponse{
			Code: consts.StatusOK,
			Msg:  "success",
		},
		SystemConfig: &systemConfig.SystemConfig{
			EnvironmentKey: cfg.EnvironmentKey,
			ConfigKey:      cfg.ConfigKey,
			ConfigValue:    cfg.ConfigValue,
			ConfigType:     cfg.ConfigType,
			Remark:         cfg.Remark,
		},
	}
	c.JSON(consts.StatusOK, resp)
}

// Update .
// @router /api/v1/system-config/update [POST]
// SystemConfig is environment-scoped only (no pipeline_key dependency).
func Update(ctx context.Context, c *app.RequestContext) {
	var req systemConfig.UpdateSystemConfigRequest
	if err := c.BindAndValidate(&req); err != nil {
		handler.RespondError(c, consts.StatusBadRequest, err)
		return
	}

	if req.SystemConfig == nil {
		handler.RespondError(c, consts.StatusBadRequest, errors.New("systemConfig is required"))
		return
	}
	if req.SystemConfig.EnvironmentKey == "" {
		handler.RespondError(c, consts.StatusBadRequest, errors.New("environment_key is required"))
		return
	}
	if req.SystemConfig.ConfigKey == "" {
		handler.RespondError(c, consts.StatusBadRequest, errors.New("config_key is required"))
		return
	}

	if err := svc.UpdateSystemConfig(
		handler.EnrichContext(ctx, c),
		req.SystemConfig.EnvironmentKey,
		req.SystemConfig.ConfigKey,
		req.SystemConfig.ConfigValue,
		req.SystemConfig.ConfigType,
		req.SystemConfig.Remark,
	); err != nil {
		status := consts.StatusInternalServerError
		if errors.Is(err, service.ErrInvalidSystemConfigKey) {
			status = consts.StatusBadRequest
		}
		handler.RespondError(c, status, err)
		return
	}

	resp := &systemConfig.SystemConfigResponse{
		OperateResponse: &common.OperateResponse{
			Code: consts.StatusOK,
			Msg:  "success",
		},
		SystemConfig: req.SystemConfig,
	}
	c.JSON(consts.StatusOK, resp)
}

// List .
// @router /api/v1/system-config/list [GET]
// SystemConfig is environment-scoped only (no pipeline_key dependency).
func List(ctx context.Context, c *app.RequestContext) {
	var req systemConfig.ListSystemConfigRequest
	if err := c.BindAndValidate(&req); err != nil {
		handler.RespondError(c, consts.StatusBadRequest, err)
		return
	}

	if req.EnvironmentKey == "" {
		handler.RespondError(c, consts.StatusBadRequest, errors.New("environment_key is required"))
		return
	}

	configs, err := svc.ListSystemConfigsByEnv(handler.EnrichContext(ctx, c), req.EnvironmentKey)
	if err != nil {
		handler.RespondError(c, consts.StatusInternalServerError, err)
		return
	}

	list := make([]*systemConfig.SystemConfig, 0, len(configs))
	for _, cfg := range configs {
		list = append(list, &systemConfig.SystemConfig{
			EnvironmentKey: cfg.EnvironmentKey,
			ConfigKey:      cfg.ConfigKey,
			ConfigValue:    cfg.ConfigValue,
			ConfigType:     cfg.ConfigType,
			Remark:         cfg.Remark,
		})
	}

	resp := &systemConfig.SystemConfigListResponse{
		List: list,
	}
	c.JSON(consts.StatusOK, resp)
}

// Create .
// @router /api/v1/system-config/create [POST]
// SystemConfig is environment-scoped only (no pipeline_key dependency).
func Create(ctx context.Context, c *app.RequestContext) {
	var req systemConfig.CreateSystemConfigRequest
	if err := c.BindAndValidate(&req); err != nil {
		handler.RespondError(c, consts.StatusBadRequest, err)
		return
	}

	if req.SystemConfig == nil {
		handler.RespondError(c, consts.StatusBadRequest, errors.New("system_config is required"))
		return
	}
	if req.SystemConfig.EnvironmentKey == "" {
		handler.RespondError(c, consts.StatusBadRequest, errors.New("environment_key is required"))
		return
	}
	if req.SystemConfig.ConfigKey == "" {
		handler.RespondError(c, consts.StatusBadRequest, errors.New("config_key is required"))
		return
	}

	if err := svc.CreateSystemConfig(
		handler.EnrichContext(ctx, c),
		req.SystemConfig.EnvironmentKey,
		req.SystemConfig.ConfigKey,
		req.SystemConfig.ConfigValue,
		req.SystemConfig.ConfigType,
		req.SystemConfig.Remark,
	); err != nil {
		status := consts.StatusInternalServerError
		if errors.Is(err, service.ErrSystemConfigKeyRequired) || errors.Is(err, service.ErrSystemConfigKeyExists) {
			status = consts.StatusBadRequest
		}
		handler.RespondError(c, status, err)
		return
	}

	resp := &systemConfig.SystemConfigResponse{
		OperateResponse: &common.OperateResponse{
			Code: consts.StatusOK,
			Msg:  "success",
		},
		SystemConfig: req.SystemConfig,
	}
	c.JSON(consts.StatusOK, resp)
}

// Delete .
// @router /api/v1/system-config/delete [POST]
// SystemConfig is environment-scoped only (no pipeline_key dependency).
func Delete(ctx context.Context, c *app.RequestContext) {
	var req systemConfig.DeleteSystemConfigRequest
	if err := c.BindAndValidate(&req); err != nil {
		handler.RespondError(c, consts.StatusBadRequest, err)
		return
	}

	if req.EnvironmentKey == "" {
		handler.RespondError(c, consts.StatusBadRequest, errors.New("environment_key is required"))
		return
	}
	if req.ConfigKey == "" {
		handler.RespondError(c, consts.StatusBadRequest, errors.New("config_key is required"))
		return
	}

	if err := svc.DeleteSystemConfig(
		handler.EnrichContext(ctx, c),
		req.EnvironmentKey,
		req.ConfigKey,
	); err != nil {
		status := consts.StatusInternalServerError
		if errors.Is(err, service.ErrProtectedSystemConfig) || errors.Is(err, service.ErrSystemConfigKeyRequired) {
			status = consts.StatusBadRequest
		}
		if errors.Is(err, service.ErrSystemConfigNotFound) {
			status = consts.StatusNotFound
		}
		handler.RespondError(c, status, err)
		return
	}

	resp := &common.OperateResponse{
		Code: consts.StatusOK,
		Msg:  "success",
	}
	c.JSON(consts.StatusOK, resp)
}
