// Code generated by hertz generator.

package transfer

import (
	"context"
	"errors"
	"fmt"
	"io"
	"strings"

	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/protocol/consts"
	"github.com/yi-nology/rainbow_bridge/biz/handler"
	"github.com/yi-nology/rainbow_bridge/biz/model/transfer"
	"github.com/yi-nology/rainbow_bridge/biz/service"
)

var svc *service.Service

func SetService(s *service.Service) {
	svc = s
}

// Import .
// @router /api/v1/transfer/import [POST]
func Import(ctx context.Context, c *app.RequestContext) {
	contentType := strings.ToLower(string(c.GetHeader("Content-Type")))
	if strings.HasPrefix(contentType, "multipart/form-data") {
		fileHeader, err := c.FormFile("archive")
		if err != nil {
			handler.RespondError(c, consts.StatusBadRequest, err)
			return
		}
		file, err := fileHeader.Open()
		if err != nil {
			handler.RespondError(c, consts.StatusBadRequest, err)
			return
		}
		defer file.Close()

		data, err := io.ReadAll(file)
		if err != nil {
			handler.RespondError(c, consts.StatusInternalServerError, err)
			return
		}
		overwrite := strings.ToLower(string(c.FormValue("overwrite"))) == "true"
		configs, err := svc.ImportConfigsArchive(handler.EnrichContext(ctx, c), data, overwrite)
		if err != nil {
			handler.RespondError(c, consts.StatusInternalServerError, err)
			return
		}
		handler.RespondOKWithSummary(c, handler.BuildConfigSummary(configs))
		return
	}

	req := &transfer.ImportRequest{}
	if err := c.BindJSON(req); err != nil {
		handler.RespondError(c, consts.StatusBadRequest, err)
		return
	}
	if len(req.Configs) == 0 {
		handler.RespondError(c, consts.StatusBadRequest, errors.New("configs cannot be empty"))
		return
	}
	if err := svc.ImportConfigs(handler.EnrichContext(ctx, c), req.GetConfigs(), req.GetOverwrite()); err != nil {
		handler.RespondError(c, consts.StatusInternalServerError, err)
		return
	}
	handler.RespondOKWithSummary(c, handler.BuildConfigSummary(req.Configs))
}

// Export .
// @router /api/v1/transfer/export [GET]
func Export(ctx context.Context, c *app.RequestContext) {
	environmentKey := strings.TrimSpace(c.Query("environment_key"))
	pipelineKey := strings.TrimSpace(c.Query("pipeline_key"))
	format := strings.ToLower(strings.TrimSpace(c.Query("format")))
	includeSystemConfig := strings.ToLower(strings.TrimSpace(c.Query("include_system_config"))) == "true"
	systemConfigOnly := strings.ToLower(strings.TrimSpace(c.Query("system_config_only"))) == "true"

	// 如果 environment_key 和 pipeline_key 都为空或为 "all"，导出所有环境和流水线
	if (environmentKey == "" || environmentKey == "all") && (pipelineKey == "" || pipelineKey == "all") {
		switch format {
		case "zip":
			data, filename, err := svc.ExportConfigsArchiveAll(handler.EnrichContext(ctx, c), includeSystemConfig)
			if err != nil {
				handler.RespondError(c, consts.StatusInternalServerError, err)
				return
			}
			c.Header("Content-Type", "application/zip")
			c.Header("Content-Disposition", fmt.Sprintf(`attachment; filename="%s"`, filename))
			c.Data(consts.StatusOK, "application/zip", data)
			return
		default:
			handler.RespondError(c, consts.StatusBadRequest, errors.New("export all only supports zip format"))
			return
		}
	}

	if environmentKey == "" || pipelineKey == "" {
		handler.RespondError(c, consts.StatusBadRequest, errors.New("environment_key and pipeline_key are required"))
		return
	}

	switch format {
	case "zip":
		data, filename, err := svc.ExportConfigsArchive(handler.EnrichContext(ctx, c), environmentKey, pipelineKey, includeSystemConfig, systemConfigOnly)
		if err != nil {
			handler.RespondError(c, consts.StatusInternalServerError, err)
			return
		}
		c.Header("Content-Type", "application/zip")
		c.Header("Content-Disposition", fmt.Sprintf(`attachment; filename="%s"`, filename))
		c.Data(consts.StatusOK, "application/zip", data)

	default: // json
		configs, err := svc.ExportConfigs(handler.EnrichContext(ctx, c), environmentKey, pipelineKey, includeSystemConfig, systemConfigOnly)
		if err != nil {
			handler.RespondError(c, consts.StatusInternalServerError, err)
			return
		}
		c.JSON(consts.StatusOK, map[string]any{
			"list": configs,
		})
	}
}
