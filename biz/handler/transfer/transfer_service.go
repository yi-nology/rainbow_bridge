// Code generated by hertz generator.

package transfer

import (
	"context"
	"errors"
	"fmt"
	"io"
	"strings"

	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/protocol/consts"
	"github.com/yi-nology/rainbow_bridge/biz/handler"
	"github.com/yi-nology/rainbow_bridge/biz/model/api"
	"github.com/yi-nology/rainbow_bridge/biz/service"
)

var svc *service.Service

func SetService(s *service.Service) {
	svc = s
}

// Import .
// @router /api/v1/transfer/import [POST]
func Import(ctx context.Context, c *app.RequestContext) {
	contentType := strings.ToLower(string(c.GetHeader("Content-Type")))
	if strings.HasPrefix(contentType, "multipart/form-data") {
		fileHeader, err := c.FormFile("archive")
		if err != nil {
			handler.RespondError(c, consts.StatusBadRequest, err)
			return
		}
		file, err := fileHeader.Open()
		if err != nil {
			handler.RespondError(c, consts.StatusBadRequest, err)
			return
		}
		defer file.Close()

		data, err := io.ReadAll(file)
		if err != nil {
			handler.RespondError(c, consts.StatusInternalServerError, err)
			return
		}
		overwrite := strings.ToLower(string(c.FormValue("overwrite"))) == "true"
		configs, err := svc.ImportConfigsArchive(handler.EnrichContext(ctx, c), data, overwrite)
		if err != nil {
			handler.RespondError(c, consts.StatusInternalServerError, err)
			return
		}
		handler.RespondOKWithSummary(c, handler.BuildConfigSummary(configs))
		return
	}

	req := &api.ResourceImportRequest{}
	if err := c.BindJSON(req); err != nil {
		handler.RespondError(c, consts.StatusBadRequest, err)
		return
	}
	if len(req.Configs) == 0 {
		handler.RespondError(c, consts.StatusBadRequest, errors.New("configs cannot be empty"))
		return
	}
	if err := svc.ImportConfigs(handler.EnrichContext(ctx, c), req); err != nil {
		handler.RespondError(c, consts.StatusInternalServerError, err)
		return
	}
	handler.RespondOKWithSummary(c, handler.BuildConfigSummary(req.Configs))
}

// Export .
// @router /api/v1/transfer/export [GET]
func Export(ctx context.Context, c *app.RequestContext) {
	environmentKey := strings.TrimSpace(c.Query("environment_key"))
	pipelineKey := strings.TrimSpace(c.Query("pipeline_key"))
	format := strings.ToLower(strings.TrimSpace(c.Query("format")))

	if environmentKey == "" || pipelineKey == "" {
		handler.RespondError(c, consts.StatusBadRequest, errors.New("environment_key and pipeline_key are required"))
		return
	}

	req := &api.ResourceExportRequest{
		EnvironmentKey: environmentKey,
		PipelineKey:    pipelineKey,
	}

	switch format {
	case "zip":
		data, filename, err := svc.ExportConfigsArchive(handler.EnrichContext(ctx, c), req)
		if err != nil {
			handler.RespondError(c, consts.StatusInternalServerError, err)
			return
		}
		c.Header("Content-Type", "application/zip")
		c.Header("Content-Disposition", fmt.Sprintf(`attachment; filename="%s"`, filename))
		c.Data(consts.StatusOK, "application/zip", data)

	case "nginx", "static":
		data, filename, err := svc.ExportStaticBundle(handler.EnrichContext(ctx, c), req)
		if err != nil {
			handler.RespondError(c, consts.StatusInternalServerError, err)
			return
		}
		c.Header("Content-Type", "application/zip")
		c.Header("Content-Disposition", fmt.Sprintf(`attachment; filename="%s"`, filename))
		c.Data(consts.StatusOK, "application/zip", data)

	default: // json
		configs, err := svc.ExportConfigs(handler.EnrichContext(ctx, c), req)
		if err != nil {
			handler.RespondError(c, consts.StatusInternalServerError, err)
			return
		}
		c.JSON(consts.StatusOK, map[string]any{
			"list": configs,
		})
	}
}

// ExportStaticSelected .
// @router /api/v1/transfer/export/static/selected [GET]
func ExportStaticSelected(ctx context.Context, c *app.RequestContext) {
	environmentKey := strings.TrimSpace(c.Query("environment_key"))
	pipelineKey := strings.TrimSpace(c.Query("pipeline_key"))

	if environmentKey == "" {
		environmentKey = "default"
	}
	if pipelineKey == "" {
		pipelineKey = "default"
	}

	req := &api.ResourceExportRequest{
		EnvironmentKey: environmentKey,
		PipelineKey:    pipelineKey,
	}

	data, filename, err := svc.ExportStaticBundle(handler.EnrichContext(ctx, c), req)
	if err != nil {
		handler.WriteInternalError(c, err)
		return
	}

	c.Header("Content-Type", "application/zip")
	c.Header("Content-Disposition", fmt.Sprintf(`attachment; filename="%s"`, filename))
	c.Data(consts.StatusOK, "application/zip", data)
}

// ExportStaticAll .
// @router /api/v1/transfer/export/static/all [GET]
func ExportStaticAll(ctx context.Context, c *app.RequestContext) {
	data, filename, err := svc.ExportStaticBundleAll(handler.EnrichContext(ctx, c))
	if err != nil {
		handler.WriteInternalError(c, err)
		return
	}

	c.Header("Content-Type", "application/zip")
	c.Header("Content-Disposition", fmt.Sprintf(`attachment; filename="%s"`, filename))
	c.Data(consts.StatusOK, "application/zip", data)
}
