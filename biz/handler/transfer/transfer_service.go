// Code generated by hertz generator.

package transfer

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"strings"

	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/protocol/consts"
	"github.com/yi-nology/rainbow_bridge/biz/handler"
	"github.com/yi-nology/rainbow_bridge/biz/model/transfer"
	"github.com/yi-nology/rainbow_bridge/biz/service"
)

var svc *service.Service

func SetService(s *service.Service) {
	svc = s
}

// Import .
// @router /api/v1/transfer/import [POST]
func Import(ctx context.Context, c *app.RequestContext) {
	contentType := strings.ToLower(string(c.GetHeader("Content-Type")))
	if strings.HasPrefix(contentType, "multipart/form-data") {
		fileHeader, err := c.FormFile("archive")
		if err != nil {
			c.JSON(consts.StatusOK, &transfer.ImportResponse{
				Code:  consts.StatusBadRequest,
				Msg:   "error",
				Error: err.Error(),
			})
			return
		}
		file, err := fileHeader.Open()
		if err != nil {
			c.JSON(consts.StatusOK, &transfer.ImportResponse{
				Code:  consts.StatusBadRequest,
				Msg:   "error",
				Error: err.Error(),
			})
			return
		}
		defer file.Close()

		data, err := io.ReadAll(file)
		if err != nil {
			c.JSON(consts.StatusOK, &transfer.ImportResponse{
				Code:  consts.StatusInternalServerError,
				Msg:   "error",
				Error: err.Error(),
			})
			return
		}

		// 获取目标环境和渠道（用户在前端选择的）
		targetEnv := strings.TrimSpace(string(c.FormValue("environment_key")))
		targetPipeline := strings.TrimSpace(string(c.FormValue("pipeline_key")))
		overwrite := strings.ToLower(string(c.FormValue("overwrite"))) == "true"

		configs, err := svc.ImportConfigsArchive(handler.EnrichContext(ctx, c), data, targetEnv, targetPipeline, overwrite)
		if err != nil {
			c.JSON(consts.StatusOK, &transfer.ImportResponse{
				Code:  consts.StatusInternalServerError,
				Msg:   "error",
				Error: err.Error(),
			})
			return
		}
		summary := handler.BuildConfigSummary(configs)
		c.JSON(consts.StatusOK, &transfer.ImportResponse{
			Code: consts.StatusOK,
			Msg:  "OK",
			Data: &transfer.ImportSummary{
				Total:           int32(summary.Total),
				EnvironmentKeys: summary.EnvironmentKeys,
				PipelineKeys:    summary.PipelineKeys,
				Items:           convertToImportSummaryItems(summary.Items),
			},
		})
		return
	}

	req := &transfer.ImportRequest{}
	if err := c.BindJSON(req); err != nil {
		c.JSON(consts.StatusOK, &transfer.ImportResponse{
			Code:  consts.StatusBadRequest,
			Msg:   "error",
			Error: err.Error(),
		})
		return
	}
	if len(req.Configs) == 0 {
		c.JSON(consts.StatusOK, &transfer.ImportResponse{
			Code:  consts.StatusBadRequest,
			Msg:   "error",
			Error: "configs cannot be empty",
		})
		return
	}
	if err := svc.ImportConfigs(handler.EnrichContext(ctx, c), req.GetConfigs(), req.GetOverwrite()); err != nil {
		c.JSON(consts.StatusOK, &transfer.ImportResponse{
			Code:  consts.StatusInternalServerError,
			Msg:   "error",
			Error: err.Error(),
		})
		return
	}
	summary := handler.BuildConfigSummary(req.Configs)
	c.JSON(consts.StatusOK, &transfer.ImportResponse{
		Code: consts.StatusOK,
		Msg:  "OK",
		Data: &transfer.ImportSummary{
			Total:           int32(summary.Total),
			EnvironmentKeys: summary.EnvironmentKeys,
			PipelineKeys:    summary.PipelineKeys,
			Items:           convertToImportSummaryItems(summary.Items),
		},
	})
}

func convertToImportSummaryItems(items []handler.SummaryItem) []*transfer.ImportSummaryItem {
	result := make([]*transfer.ImportSummaryItem, len(items))
	for i, item := range items {
		result[i] = &transfer.ImportSummaryItem{
			ResourceKey:    item.ResourceKey,
			EnvironmentKey: item.EnvironmentKey,
			PipelineKey:    item.PipelineKey,
			Name:           item.Name,
			Alias:          item.Alias,
			Type:           item.Type,
		}
	}
	return result
}

// Export .
// @router /api/v1/transfer/export [GET]
func Export(ctx context.Context, c *app.RequestContext) {
	environmentKey := strings.TrimSpace(c.Query("environment_key"))
	pipelineKey := strings.TrimSpace(c.Query("pipeline_key"))
	format := strings.ToLower(strings.TrimSpace(c.Query("format")))

	// 如果 environment_key 和 pipeline_key 都为空或为 "all"，导出所有环境和渠道
	if (environmentKey == "" || environmentKey == "all") && (pipelineKey == "" || pipelineKey == "all") {
		switch format {
		case "zip":
			data, filename, err := svc.ExportConfigsArchiveAll(handler.EnrichContext(ctx, c))
			if err != nil {
				c.JSON(consts.StatusOK, &transfer.ExportResponse{
					Code:  consts.StatusInternalServerError,
					Msg:   "error",
					Error: err.Error(),
				})
				return
			}
			c.Header("Content-Type", "application/zip")
			c.Header("Content-Disposition", fmt.Sprintf(`attachment; filename="%s"`, filename))
			c.Data(consts.StatusOK, "application/zip", data)
			return
		default:
			c.JSON(consts.StatusOK, &transfer.ExportResponse{
				Code:  consts.StatusBadRequest,
				Msg:   "error",
				Error: "export all only supports zip format",
			})
			return
		}
	}

	if environmentKey == "" || pipelineKey == "" {
		c.JSON(consts.StatusOK, &transfer.ExportResponse{
			Code:  consts.StatusBadRequest,
			Msg:   "error",
			Error: "environment_key and pipeline_key are required",
		})
		return
	}

	switch format {
	case "zip":
		data, filename, err := svc.ExportConfigsArchive(handler.EnrichContext(ctx, c), environmentKey, pipelineKey)
		if err != nil {
			c.JSON(consts.StatusOK, &transfer.ExportResponse{
				Code:  consts.StatusInternalServerError,
				Msg:   "error",
				Error: err.Error(),
			})
			return
		}
		c.Header("Content-Type", "application/zip")
		c.Header("Content-Disposition", fmt.Sprintf(`attachment; filename="%s"`, filename))
		c.Data(consts.StatusOK, "application/zip", data)

	default: // json
		configs, err := svc.ExportConfigs(handler.EnrichContext(ctx, c), environmentKey, pipelineKey)
		if err != nil {
			c.JSON(consts.StatusOK, &transfer.ExportResponse{
				Code:  consts.StatusInternalServerError,
				Msg:   "error",
				Error: err.Error(),
			})
			return
		}
		c.JSON(consts.StatusOK, &transfer.ExportResponse{
			Code: consts.StatusOK,
			Msg:  "OK",
			Data: &transfer.ExportData{
				Total: int32(len(configs)),
				List:  configs,
			},
		})
	}
}

// Migrate migrates configurations between environments/pipelines.
// @router /api/v1/transfer/migrate [POST]
func Migrate(ctx context.Context, c *app.RequestContext) {
	req := &transfer.MigrateRequest{}
	if err := c.BindJSON(req); err != nil {
		c.JSON(consts.StatusOK, &transfer.MigrateResponse{
			Code:  consts.StatusBadRequest,
			Msg:   "error",
			Error: err.Error(),
		})
		return
	}

	// 参数校验
	if req.SourceEnvironmentKey == "" || req.SourcePipelineKey == "" {
		c.JSON(consts.StatusOK, &transfer.MigrateResponse{
			Code:  consts.StatusBadRequest,
			Msg:   "error",
			Error: "source_environment_key and source_pipeline_key are required",
		})
		return
	}
	if req.TargetEnvironmentKey == "" || req.TargetPipelineKey == "" {
		c.JSON(consts.StatusOK, &transfer.MigrateResponse{
			Code:  consts.StatusBadRequest,
			Msg:   "error",
			Error: "target_environment_key and target_pipeline_key are required",
		})
		return
	}
	if req.SourceEnvironmentKey == req.TargetEnvironmentKey &&
		req.SourcePipelineKey == req.TargetPipelineKey {
		c.JSON(consts.StatusOK, &transfer.MigrateResponse{
			Code:  consts.StatusBadRequest,
			Msg:   "error",
			Error: "source and target cannot be the same",
		})
		return
	}

	// 调用 Service 层
	data, err := svc.MigrateConfigs(handler.EnrichContext(ctx, c), req)
	if err != nil {
		c.JSON(consts.StatusOK, &transfer.MigrateResponse{
			Code:  consts.StatusInternalServerError,
			Msg:   "error",
			Error: err.Error(),
		})
		return
	}

	c.JSON(consts.StatusOK, &transfer.MigrateResponse{
		Code: consts.StatusOK,
		Msg:  "OK",
		Data: data,
	})
}

// ExportTree returns the tree structure of environments, pipelines, and configs.
// @router /api/v1/transfer/export-tree [GET]
func ExportTree(ctx context.Context, c *app.RequestContext) {
	tree, err := svc.GetExportTree(handler.EnrichContext(ctx, c))
	if err != nil {
		c.JSON(consts.StatusOK, &transfer.ExportTreeResponse{
			Code:  consts.StatusInternalServerError,
			Msg:   "error",
			Error: err.Error(),
		})
		return
	}

	c.JSON(consts.StatusOK, &transfer.ExportTreeResponse{
		Code: consts.StatusOK,
		Msg:  "OK",
		Data: tree,
	})
}

// ExportSelective exports selected configurations.
// @router /api/v1/transfer/export [POST]
func ExportSelective(ctx context.Context, c *app.RequestContext) {
	req := &transfer.ExportSelectiveRequest{}
	if err := c.BindJSON(req); err != nil {
		c.JSON(consts.StatusOK, &transfer.ExportResponse{
			Code:  consts.StatusBadRequest,
			Msg:   "error",
			Error: err.Error(),
		})
		return
	}

	if len(req.Selections) == 0 {
		c.JSON(consts.StatusOK, &transfer.ExportResponse{
			Code:  consts.StatusBadRequest,
			Msg:   "error",
			Error: "selections cannot be empty",
		})
		return
	}

	format := strings.ToLower(strings.TrimSpace(req.Format))
	if format == "" {
		format = "zip"
	}

	data, filename, err := svc.ExportConfigsSelective(handler.EnrichContext(ctx, c), req.Selections, format)
	if err != nil {
		c.JSON(consts.StatusOK, &transfer.ExportResponse{
			Code:  consts.StatusInternalServerError,
			Msg:   "error",
			Error: err.Error(),
		})
		return
	}

	var contentType string
	switch format {
	case "tar.gz":
		contentType = "application/gzip"
	default:
		contentType = "application/zip"
	}

	c.Header("Content-Type", contentType)
	c.Header("Content-Disposition", fmt.Sprintf(`attachment; filename="%s"`, filename))
	c.Data(consts.StatusOK, contentType, data)
}

// ImportPreview previews the import file contents and detects conflicts.
// @router /api/v1/transfer/import-preview [POST]
func ImportPreview(ctx context.Context, c *app.RequestContext) {
	fileHeader, err := c.FormFile("file")
	if err != nil {
		c.JSON(consts.StatusOK, &transfer.ImportPreviewResponse{
			Code:  consts.StatusBadRequest,
			Msg:   "error",
			Error: "file is required: " + err.Error(),
		})
		return
	}

	file, err := fileHeader.Open()
	if err != nil {
		c.JSON(consts.StatusOK, &transfer.ImportPreviewResponse{
			Code:  consts.StatusBadRequest,
			Msg:   "error",
			Error: err.Error(),
		})
		return
	}
	defer file.Close()

	data, err := io.ReadAll(file)
	if err != nil {
		c.JSON(consts.StatusOK, &transfer.ImportPreviewResponse{
			Code:  consts.StatusInternalServerError,
			Msg:   "error",
			Error: err.Error(),
		})
		return
	}

	preview, err := svc.ImportConfigsPreview(handler.EnrichContext(ctx, c), data, fileHeader.Filename)
	if err != nil {
		c.JSON(consts.StatusOK, &transfer.ImportPreviewResponse{
			Code:  consts.StatusInternalServerError,
			Msg:   "error",
			Error: err.Error(),
		})
		return
	}

	c.JSON(consts.StatusOK, &transfer.ImportPreviewResponse{
		Code: consts.StatusOK,
		Msg:  "OK",
		Data: preview,
	})
}

// ImportSelective imports selected configurations from an archive.
// @router /api/v1/transfer/import-selective [POST]
func ImportSelective(ctx context.Context, c *app.RequestContext) {
	fileHeader, err := c.FormFile("file")
	if err != nil {
		c.JSON(consts.StatusOK, &transfer.ImportResponse{
			Code:  consts.StatusBadRequest,
			Msg:   "error",
			Error: "file is required: " + err.Error(),
		})
		return
	}

	file, err := fileHeader.Open()
	if err != nil {
		c.JSON(consts.StatusOK, &transfer.ImportResponse{
			Code:  consts.StatusBadRequest,
			Msg:   "error",
			Error: err.Error(),
		})
		return
	}
	defer file.Close()

	data, err := io.ReadAll(file)
	if err != nil {
		c.JSON(consts.StatusOK, &transfer.ImportResponse{
			Code:  consts.StatusInternalServerError,
			Msg:   "error",
			Error: err.Error(),
		})
		return
	}

	// Parse selections from form value
	selectionsStr := strings.TrimSpace(string(c.FormValue("selections")))
	overwrite := strings.ToLower(string(c.FormValue("overwrite"))) == "true"

	var selections []*transfer.ExportSelection
	if selectionsStr != "" {
		if err := json.Unmarshal([]byte(selectionsStr), &selections); err != nil {
			c.JSON(consts.StatusOK, &transfer.ImportResponse{
				Code:  consts.StatusBadRequest,
				Msg:   "error",
				Error: "invalid selections format: " + err.Error(),
			})
			return
		}
	}

	configs, err := svc.ImportConfigsSelective(handler.EnrichContext(ctx, c), data, fileHeader.Filename, selections, overwrite)
	if err != nil {
		c.JSON(consts.StatusOK, &transfer.ImportResponse{
			Code:  consts.StatusInternalServerError,
			Msg:   "error",
			Error: err.Error(),
		})
		return
	}

	summary := handler.BuildConfigSummary(configs)
	c.JSON(consts.StatusOK, &transfer.ImportResponse{
		Code: consts.StatusOK,
		Msg:  "OK",
		Data: &transfer.ImportSummary{
			Total:           int32(summary.Total),
			EnvironmentKeys: summary.EnvironmentKeys,
			PipelineKeys:    summary.PipelineKeys,
			Items:           convertToImportSummaryItems(summary.Items),
		},
	})
}
