// Code generated by hertz generator.

package main

import (
	"context"
	"embed"
	"io/fs"
	"log"

	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/app/server"
	hconfig "github.com/cloudwego/hertz/pkg/common/config"
	resourcemodel "github.com/yi-nology/rainbow_bridge/biz/dal/model"
	"github.com/yi-nology/rainbow_bridge/biz/middleware"
	bizrouter "github.com/yi-nology/rainbow_bridge/biz/router"
	resourceservice "github.com/yi-nology/rainbow_bridge/biz/service"
	appconfig "github.com/yi-nology/rainbow_bridge/pkg/config"
	"github.com/yi-nology/rainbow_bridge/pkg/database"
	"gorm.io/gorm"
)

//go:embed web/*
var embeddedWeb embed.FS

func main() {
	cfg, err := appconfig.Load("config.yaml")
	if err != nil {
		log.Fatalf("load config: %v", err)
	}

	db, err := database.Open(cfg.Database)
	if err != nil {
		log.Fatalf("open database: %v", err)
	}

	if err := db.AutoMigrate(&resourcemodel.Config{}, &resourcemodel.Asset{}, &resourcemodel.Environment{}, &resourcemodel.Pipeline{}, &resourcemodel.SystemConfig{}); err != nil {
		log.Fatalf("auto migrate: %v", err)
	}

	// Drop old unique index on pipeline table if it exists
	if err := dropOldPipelineIndex(db); err != nil {
		log.Fatalf("drop old pipeline index: %v", err)
	}

	// Migrate existing configs with default environment_key and pipeline_key
	if err := resourceservice.MigrateConfigDefaults(db); err != nil {
		log.Fatalf("migrate config defaults: %v", err)
	}

	if err := resourceservice.EnsureSystemDefaults(context.Background(), db); err != nil {
		log.Fatalf("seed system defaults: %v", err)
	}

	basePath := appconfig.NormalizeBasePath(cfg.Server.BasePath)
	opts := []hconfig.Option{server.WithHostPorts(cfg.Server.Address)}
	if basePath != "" {
		opts = append(opts, server.WithBasePath(basePath))
	}
	h := server.Default(opts...)

	resourceService := resourceservice.NewService(db, basePath)

	// Initialize handlers with service
	bizrouter.InitHandlers(resourceService)

	// Register middleware
	h.Use(middleware.Recovery())
	h.Use(middleware.Logging())
	h.Use(middleware.CORS(&cfg.CORS))
	h.Use(middleware.Auth())
	// Register generated routes
	bizrouter.GeneratedRegister(h)

	webFS, err := fs.Sub(embeddedWeb, "web")
	if err != nil {
		log.Fatalf("prepare web assets: %v", err)
	}
	registerStaticRoutes(h, webFS)

	if basePath != "" {
		log.Printf("server listening at %s with base path %s", cfg.Server.Address, basePath)
	} else {
		log.Printf("server listening at %s", cfg.Server.Address)
	}
	h.Spin()
}

func registerStaticRoutes(h *server.Hertz, fsys fs.FS) {
	serve := func(route, file, contentType string) {
		h.GET(route, func(ctx context.Context, c *app.RequestContext) {
			data, err := fs.ReadFile(fsys, file)
			if err != nil {
				c.Response.SetStatusCode(404)
				c.Write([]byte("Not Found"))
				return
			}
			if contentType != "" {
				c.Response.Header.Set("Content-Type", contentType)
			}
			c.Write(data)
		})
	}

	serve("/", "home.html", "text/html; charset=utf-8")
	serve("/home", "home.html", "text/html; charset=utf-8")
	serve("/home.html", "home.html", "text/html; charset=utf-8")
	serve("/index", "index.html", "text/html; charset=utf-8")
	serve("/index.html", "index.html", "text/html; charset=utf-8")
	serve("/system", "system.html", "text/html; charset=utf-8")
	serve("/system.html", "system.html", "text/html; charset=utf-8")
	serve("/assets", "assets.html", "text/html; charset=utf-8")
	serve("/assets.html", "assets.html", "text/html; charset=utf-8")
	serve("/export", "export.html", "text/html; charset=utf-8")
	serve("/export.html", "export.html", "text/html; charset=utf-8")
	serve("/import", "import.html", "text/html; charset=utf-8")
	serve("/import.html", "import.html", "text/html; charset=utf-8")
	serve("/environment", "environment.html", "text/html; charset=utf-8")
	serve("/environment.html", "environment.html", "text/html; charset=utf-8")
	serve("/pipeline", "pipeline.html", "text/html; charset=utf-8")
	serve("/pipeline.html", "pipeline.html", "text/html; charset=utf-8")
	serve("/styles.css", "styles.css", "text/css; charset=utf-8")
	serve("/config.js", "config.js", "application/javascript")
	serve("/assets.js", "assets.js", "application/javascript")
	serve("/export.js", "export.js", "application/javascript")
	serve("/import.js", "import.js", "application/javascript")
	serve("/home.js", "home.js", "application/javascript")
	serve("/components.js", "components.js", "application/javascript")
	serve("/ui.js", "ui.js", "application/javascript")
	serve("/system.js", "system.js", "application/javascript")
	serve("/environment.js", "environment.js", "application/javascript")
	serve("/pipeline.js", "pipeline.js", "application/javascript")
	serve("/runtime.js", "runtime.js", "application/javascript")
	serve("/lib/utils.js", "lib/utils.js", "application/javascript")
	serve("/lib/api.js", "lib/api.js", "application/javascript")
	serve("/lib/toast.js", "lib/toast.js", "application/javascript")
	serve("/lib/init.js", "lib/init.js", "application/javascript")
}

// dropOldPipelineIndex removes the old uk_pipeline_key unique index if it exists.
// This is needed because we changed from single-key to composite unique index.
func dropOldPipelineIndex(db *gorm.DB) error {
	// Check if the old index exists
	var indexExists bool
	switch db.Dialector.Name() {
	case "sqlite":
		// SQLite: Check sqlite_master table
		var count int64
		if err := db.Raw("SELECT COUNT(*) FROM sqlite_master WHERE type='index' AND name='uk_pipeline_key'").Scan(&count).Error; err != nil {
			return err
		}
		indexExists = count > 0
	case "mysql":
		// MySQL: Check information_schema
		var count int64
		if err := db.Raw("SELECT COUNT(*) FROM information_schema.statistics WHERE table_name='pipeline' AND index_name='uk_pipeline_key'").Scan(&count).Error; err != nil {
			return err
		}
		indexExists = count > 0
	case "postgres":
		// PostgreSQL: Check pg_indexes
		var count int64
		if err := db.Raw("SELECT COUNT(*) FROM pg_indexes WHERE tablename='pipeline' AND indexname='uk_pipeline_key'").Scan(&count).Error; err != nil {
			return err
		}
		indexExists = count > 0
	default:
		// Unknown database, skip
		return nil
	}

	if !indexExists {
		// Index doesn't exist, nothing to do
		return nil
	}

	log.Println("[Migration] Dropping old uk_pipeline_key index...")

	// Drop the old index
	migrator := db.Migrator()
	if err := migrator.DropIndex(&resourcemodel.Pipeline{}, "uk_pipeline_key"); err != nil {
		log.Printf("[Migration] Warning: Failed to drop old index: %v", err)
		// Don't fail the startup, just warn
		return nil
	}

	log.Println("[Migration] âœ“ Dropped old uk_pipeline_key index")
	return nil
}
