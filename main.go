// Code generated by hertz generator.

package main

import (
	"context"
	"io/fs"
	"log"
	"path/filepath"
	"strings"
	"time"

	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/app/server"
	hconfig "github.com/cloudwego/hertz/pkg/common/config"
	"github.com/yi-nology/rainbow_bridge/biz/dal/model"
	versionhandler "github.com/yi-nology/rainbow_bridge/biz/handler/version"
	"github.com/yi-nology/rainbow_bridge/biz/middleware"
	bizrouter "github.com/yi-nology/rainbow_bridge/biz/router"
	"github.com/yi-nology/rainbow_bridge/biz/service"
	appconfig "github.com/yi-nology/rainbow_bridge/pkg/config"
	"github.com/yi-nology/rainbow_bridge/pkg/database"
	"github.com/yi-nology/rainbow_bridge/pkg/lock"
	appredis "github.com/yi-nology/rainbow_bridge/pkg/redis"
	"github.com/yi-nology/rainbow_bridge/pkg/static"
)

var (
	// Version information, injected at build time
	Version   = "dev"
	GitCommit = "unknown"
	BuildTime = "unknown"
	// BasePath is the URL path prefix, injected at build time
	// Empty string means deploy at root path, e.g. "rainbow-bridge" means /rainbow-bridge
	BasePath = ""
)

func main() {
	cfg, err := appconfig.Load("config.yaml")
	if err != nil {
		log.Fatalf("load config: %v", err)
	}

	db, err := database.Open(cfg.Database)
	if err != nil {
		log.Fatalf("open database: %v", err)
	}

	if err := db.AutoMigrate(&model.Config{}, &model.Asset{}, &model.Environment{}, &model.Pipeline{}); err != nil {
		log.Fatalf("auto migrate: %v", err)
	}

	// Migrate existing configs with default environment_key and pipeline_key
	if err := service.MigrateConfigDefaults(db); err != nil {
		log.Fatalf("migrate config defaults: %v", err)
	}

	if err := service.EnsureSystemDefaults(context.Background(), db); err != nil {
		log.Fatalf("seed system defaults: %v", err)
	}

	// Initialize Redis distributed write lock (optional)
	if cfg.Redis.Enabled {
		redisClient, redisErr := appredis.NewClient(cfg.Redis)
		if redisErr != nil {
			log.Fatalf("connect redis: %v", redisErr)
		}
		defer redisClient.Close()
		writeLock := lock.New(redisClient, "rainbow_bridge:write_lock", 30*time.Second, 60*time.Second)
		middleware.InitWriteLock(writeLock)
		log.Printf("Redis distributed write lock enabled (%s)", cfg.Redis.Address)
	}

	// Use build-time injected BasePath instead of config file
	basePath := appconfig.NormalizeBasePath(BasePath)
	opts := []hconfig.Option{server.WithHostPorts(cfg.Server.Address)}
	if basePath != "" {
		opts = append(opts, server.WithBasePath(basePath))
	}
	h := server.Default(opts...)

	service := service.NewService(db, basePath)

	// Set version information for version handler
	versionhandler.AppVersion = Version
	versionhandler.AppGitCommit = GitCommit
	versionhandler.AppBuildTime = BuildTime
	versionhandler.IsIntranet = cfg.Intranet.Enabled

	// Initialize handlers with service
	bizrouter.InitHandlers(service)

	// Migrate to full asset paths
	if err := service.MigrateToFullAssetPaths(context.Background()); err != nil {
		log.Printf("Warning: failed to migrate asset paths: %v", err)
	}

	// Register middleware
	h.Use(middleware.Recovery())
	h.Use(middleware.Logging())
	h.Use(middleware.CORS(&cfg.CORS))
	h.Use(middleware.Auth())
	// Register all routes
	register(h)

	// Serve embedded frontend static files
	setupStaticFileServer(h, basePath)

	if basePath != "" {
		log.Printf("server listening at %s with base path %s", cfg.Server.Address, basePath)
	} else {
		log.Printf("server listening at %s", cfg.Server.Address)
	}
	h.Spin()
}

func setupStaticFileServer(h *server.Hertz, basePath string) {
	webFS, err := static.WebFS()
	if err != nil {
		log.Printf("Warning: failed to load embedded web files: %v", err)
		return
	}

	staticHandler := func(c context.Context, ctx *app.RequestContext) {
		path := string(ctx.URI().Path())

		if basePath != "" {
			path = strings.TrimPrefix(path, basePath)
		}
		if path == "" || path == "/" {
			path = "/index.html"
		}

		if !strings.HasPrefix(path, "/") {
			path = "/" + path
		}

		if ext := filepath.Ext(path); ext == "" && path != "/index.html" {
			path = "/index.html"
		}

		// embed.FS requires clean paths without leading "./" or "/"
		fsPath := strings.TrimPrefix(path, "/")
		content, err := fs.ReadFile(webFS, fsPath)
		if err != nil {
			ctx.Status(404)
			return
		}

		contentType := "application/octet-stream"
		switch filepath.Ext(path) {
		case ".html":
			contentType = "text/html; charset=utf-8"
		case ".css":
			contentType = "text/css; charset=utf-8"
		case ".js":
			contentType = "application/javascript; charset=utf-8"
		case ".json":
			contentType = "application/json; charset=utf-8"
		case ".png":
			contentType = "image/png"
		case ".jpg", ".jpeg":
			contentType = "image/jpeg"
		case ".svg":
			contentType = "image/svg+xml"
		case ".ico":
			contentType = "image/x-icon"
		case ".woff", ".woff2":
			contentType = "font/woff2"
		case ".ttf":
			contentType = "font/ttf"
		}

		ctx.Data(200, contentType, content)
	}

	if basePath != "" {
		h.NoRoute(func(c context.Context, ctx *app.RequestContext) {
			reqPath := string(ctx.URI().Path())
			if strings.HasPrefix(reqPath, basePath+"/") ||
				reqPath == basePath {
				staticHandler(c, ctx)
			} else {
				ctx.Status(404)
			}
		})
	} else {
		h.NoRoute(staticHandler)
	}
}
