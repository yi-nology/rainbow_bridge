// Code generated by hertz generator.

package main

import (
	"context"
	"embed"
	"io/fs"
	"log"
	"mime"
	"path"
	"path/filepath"
	"strings"

	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/app/server"
	hconfig "github.com/cloudwego/hertz/pkg/common/config"
	"github.com/yi-nology/rainbow_bridge/biz/dal/model"
	versionhandler "github.com/yi-nology/rainbow_bridge/biz/handler/version"
	"github.com/yi-nology/rainbow_bridge/biz/middleware"
	bizrouter "github.com/yi-nology/rainbow_bridge/biz/router"
	"github.com/yi-nology/rainbow_bridge/biz/service"
	appconfig "github.com/yi-nology/rainbow_bridge/pkg/config"
	"github.com/yi-nology/rainbow_bridge/pkg/database"
)

//go:embed all:web
var embeddedWeb embed.FS

var (
	// Version information, injected at build time
	Version   = "dev"
	GitCommit = "unknown"
	BuildTime = "unknown"
	// BasePath is the URL path prefix, injected at build time
	// Empty string means deploy at root path, e.g. "rainbow-bridge" means /rainbow-bridge
	BasePath = ""
)

func main() {
	cfg, err := appconfig.Load("config.yaml")
	if err != nil {
		log.Fatalf("load config: %v", err)
	}

	db, err := database.Open(cfg.Database)
	if err != nil {
		log.Fatalf("open database: %v", err)
	}

	if err := db.AutoMigrate(&model.Config{}, &model.Asset{}, &model.Environment{}, &model.Pipeline{}); err != nil {
		log.Fatalf("auto migrate: %v", err)
	}

	// Migrate existing configs with default environment_key and pipeline_key
	if err := service.MigrateConfigDefaults(db); err != nil {
		log.Fatalf("migrate config defaults: %v", err)
	}

	if err := service.EnsureSystemDefaults(context.Background(), db); err != nil {
		log.Fatalf("seed system defaults: %v", err)
	}

	// Use build-time injected BasePath instead of config file
	basePath := appconfig.NormalizeBasePath(BasePath)
	opts := []hconfig.Option{server.WithHostPorts(cfg.Server.Address)}
	if basePath != "" {
		opts = append(opts, server.WithBasePath(basePath))
	}
	h := server.Default(opts...)

	service := service.NewService(db, basePath)

	// Set version information for version handler
	versionhandler.AppVersion = Version
	versionhandler.AppGitCommit = GitCommit
	versionhandler.AppBuildTime = BuildTime
	versionhandler.IsIntranet = cfg.Intranet.Enabled

	// Initialize handlers with service
	bizrouter.InitHandlers(service)

	// Migrate to full asset paths
	if err := service.MigrateToFullAssetPaths(context.Background()); err != nil {
		log.Printf("Warning: failed to migrate asset paths: %v", err)
	}

	// Register middleware
	h.Use(middleware.Recovery())
	h.Use(middleware.Logging())
	h.Use(middleware.CORS(&cfg.CORS))
	h.Use(middleware.Auth())
	// Register all routes
	register(h)

	webFS, err := fs.Sub(embeddedWeb, "web")
	if err != nil {
		log.Fatalf("prepare web assets: %v", err)
	}
	registerStaticRoutes(h, webFS, basePath)

	if basePath != "" {
		log.Printf("server listening at %s with base path %s", cfg.Server.Address, basePath)
	} else {
		log.Printf("server listening at %s", cfg.Server.Address)
	}
	h.Spin()
}

func registerStaticRoutes(h *server.Hertz, fsys fs.FS, basePath string) {
	baseDir := strings.TrimPrefix(basePath, "/")

	// SPA 静态文件处理器 - 使用通配符路由
	staticHandler := func(ctx context.Context, c *app.RequestContext) {
		// 请求路径（已去掉 BasePath）
		reqPath := string(c.Param("filepath"))
		if reqPath == "" || reqPath == "/" {
			reqPath = "index.html"
		}
		// 去掉开头的 /
		reqPath = strings.TrimPrefix(reqPath, "/")

		// 构造候选的静态资源路径：优先尝试带 baseDir 前缀，其次尝试不带前缀
		candidates := []string{reqPath}
		if baseDir != "" {
			candidates = append([]string{path.Join(baseDir, reqPath)}, candidates...)
		}

		var (
			data    []byte
			readErr error
			fsPath  string
		)

		for _, p := range candidates {
			if p == "" {
				continue
			}
			data, readErr = fs.ReadFile(fsys, p)
			if readErr == nil {
				fsPath = p
				break
			}
		}

		if readErr != nil {
			// 文件不存在时回退到 index.html（SPA fallback）
			indexCandidates := []string{"index.html"}
			if baseDir != "" {
				indexCandidates = append([]string{path.Join(baseDir, "index.html")}, indexCandidates...)
			}

			for _, p := range indexCandidates {
				data, readErr = fs.ReadFile(fsys, p)
				if readErr == nil {
					c.Response.Header.Set("Content-Type", "text/html; charset=utf-8")
					_, _ = c.Write(data)
					return
				}
			}

			c.Response.SetStatusCode(404)
			_, _ = c.Write([]byte("Not Found"))
			return
		}

		// 根据实际文件路径设置 Content-Type
		contentType := mime.TypeByExtension(filepath.Ext(fsPath))
		if contentType == "" {
			contentType = "application/octet-stream"
		}
		c.Response.Header.Set("Content-Type", contentType)

		// 为 _next/static 资源设置长期缓存
		if strings.HasPrefix(fsPath, "_next/static/") || (baseDir != "" && strings.HasPrefix(fsPath, path.Join(baseDir, "_next/static")+"/")) {
			c.Response.Header.Set("Cache-Control", "public, max-age=31536000, immutable")
		}

		_, _ = c.Write(data)
	}

	// 注册根路由和通配符路由
	h.GET("/", staticHandler)
	h.GET("/*filepath", staticHandler)
}
