// Code generated by hertz generator.

package main

import (
	"context"
	"embed"
	"io/fs"
	"log"
	"mime"
	"path/filepath"
	"strings"

	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/app/server"
	hconfig "github.com/cloudwego/hertz/pkg/common/config"
	"github.com/yi-nology/rainbow_bridge/biz/dal/model"
	versionhandler "github.com/yi-nology/rainbow_bridge/biz/handler/version"
	"github.com/yi-nology/rainbow_bridge/biz/middleware"
	bizrouter "github.com/yi-nology/rainbow_bridge/biz/router"
	"github.com/yi-nology/rainbow_bridge/biz/service"
	appconfig "github.com/yi-nology/rainbow_bridge/pkg/config"
	"github.com/yi-nology/rainbow_bridge/pkg/database"
)

//go:embed all:web
var embeddedWeb embed.FS

var (
	// Version information, injected at build time
	Version   = "dev"
	GitCommit = "unknown"
	BuildTime = "unknown"
	// BasePath is the URL path prefix, injected at build time
	// Empty string means deploy at root path, e.g. "rainbow-bridge" means /rainbow-bridge
	BasePath = "rainbow-bridge"
)

func main() {
	cfg, err := appconfig.Load("config.yaml")
	if err != nil {
		log.Fatalf("load config: %v", err)
	}

	db, err := database.Open(cfg.Database)
	if err != nil {
		log.Fatalf("open database: %v", err)
	}

	if err := db.AutoMigrate(&model.Config{}, &model.Asset{}, &model.Environment{}, &model.Pipeline{}); err != nil {
		log.Fatalf("auto migrate: %v", err)
	}

	// Migrate existing configs with default environment_key and pipeline_key
	if err := service.MigrateConfigDefaults(db); err != nil {
		log.Fatalf("migrate config defaults: %v", err)
	}

	if err := service.EnsureSystemDefaults(context.Background(), db); err != nil {
		log.Fatalf("seed system defaults: %v", err)
	}

	// Use build-time injected BasePath instead of config file
	basePath := appconfig.NormalizeBasePath(BasePath)
	opts := []hconfig.Option{server.WithHostPorts(cfg.Server.Address)}
	if basePath != "" {
		opts = append(opts, server.WithBasePath(basePath))
	}
	h := server.Default(opts...)

	service := service.NewService(db, basePath)

	// Set version information for version handler
	versionhandler.AppVersion = Version
	versionhandler.AppGitCommit = GitCommit
	versionhandler.AppBuildTime = BuildTime

	// Initialize handlers with service
	bizrouter.InitHandlers(service)

	// Migrate to full asset paths
	if err := service.MigrateToFullAssetPaths(context.Background()); err != nil {
		log.Printf("Warning: failed to migrate asset paths: %v", err)
	}

	// Register middleware
	h.Use(middleware.Recovery())
	h.Use(middleware.Logging())
	h.Use(middleware.CORS(&cfg.CORS))
	h.Use(middleware.Auth())
	// Register all routes
	register(h)

	webFS, err := fs.Sub(embeddedWeb, "web")
	if err != nil {
		log.Fatalf("prepare web assets: %v", err)
	}
	registerStaticRoutes(h, webFS, basePath)

	if basePath != "" {
		log.Printf("server listening at %s with base path %s", cfg.Server.Address, basePath)
	} else {
		log.Printf("server listening at %s", cfg.Server.Address)
	}
	h.Spin()
}

func registerStaticRoutes(h *server.Hertz, fsys fs.FS, basePath string) {
	// SPA 静态文件处理器 - 使用通配符路由
	staticHandler := func(ctx context.Context, c *app.RequestContext) {
		path := string(c.Param("filepath"))
		if path == "" || path == "/" {
			path = "index.html"
		}
		path = strings.TrimPrefix(path, "/")

		// 尝试读取文件
		data, err := fs.ReadFile(fsys, path)
		if err != nil {
			// 文件不存在，返回 index.html (SPA fallback)
			data, err = fs.ReadFile(fsys, "index.html")
			if err != nil {
				c.Response.SetStatusCode(404)
				c.Write([]byte("Not Found"))
				return
			}
			c.Response.Header.Set("Content-Type", "text/html; charset=utf-8")
			c.Write(data)
			return
		}

		// 设置 Content-Type
		contentType := mime.TypeByExtension(filepath.Ext(path))
		if contentType == "" {
			contentType = "application/octet-stream"
		}
		c.Response.Header.Set("Content-Type", contentType)

		// 为 _next/static 资源设置长期缓存
		if strings.HasPrefix(path, "_next/static/") {
			c.Response.Header.Set("Cache-Control", "public, max-age=31536000, immutable")
		}

		c.Write(data)
	}

	// 注册根路由和通配符路由
	h.GET("/", staticHandler)
	h.GET("/*filepath", staticHandler)
}
